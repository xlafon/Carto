<!DOCTYPE html>
<html>
<head>
  <title>Carte Leaflet - Sélection multiple de lignes de bus</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <style>
    #map { height: 600px; }
    #route-selector {
      margin: 10px;
    }
    .checkbox-item {
      display: flex;
      align-items: center;
      margin-bottom: 5px;
    }
    .checkbox-item input {
      margin-right: 10px;
    }
    #route-info {
      position: absolute;
      bottom: 20px;
      left: 20px;
      background-color: rgba(255, 255, 255, 0.9);
      padding: 10px;
      border-radius: 5px;
      width: 250px;
      height: 200px;
      overflow-y: auto;
      display: none;
      z-index: 1000;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
    }
    #route-title {
      font-size: 16px;
      font-weight: bold;
    }
  </style>
</head>
<body>

<div id="route-selector">
  <label>Choisir une ou plusieurs lignes de transport :</label><br/>
  <div id="checkbox-container"></div>
</div>

<div id="map"></div>

<!-- Panneau d'informations -->
<div id="route-info">
  <h4 id="route-title"></h4>
  <div id="route-content"></div>
</div>

<script>
// Initialisation de la carte centrée sur Bayonne
var map = L.map('map').setView([43.492949, -1.474841], 13); // Coordonnées de Bayonne

// Ajouter une couche de tuiles OpenStreetMap
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  maxZoom: 19
}).addTo(map);

// Liste des marqueurs et tracés
let markersLayer = L.layerGroup().addTo(map);
let allLinesLayer = L.layerGroup(); // Couche pour toutes les lignes
let linesLayers = {}; // Object pour stocker chaque ligne par id

// Fonction pour charger et parser les fichiers GTFS depuis différents dossiers
async function fetchGTFSFile(folder, fileName) {
  const response = await fetch(`GTFS/${folder}/${fileName}`);
  const text = await response.text();
  const data = Papa.parse(text, {header: true}).data;
  return data;
}

// Charger les fichiers GTFS de plusieurs répertoires
async function loadGTFSData() {
  const folders = ['TXIKNORD', 'TXIKSUD', 'TXIKEST', 'BEARN']; // Ajouter tous les répertoires ici

  let stops = [], trips = [], stopTimes = [], routes = [], shapes = [], agency = [];

  for (const folder of folders) {
    const folderStops = await fetchGTFSFile(folder, 'stops.txt');
    const folderTrips = await fetchGTFSFile(folder, 'trips.txt');
    const folderStopTimes = await fetchGTFSFile(folder, 'stop_times.txt');
    const folderRoutes = await fetchGTFSFile(folder, 'routes.txt');
    const folderShapes = await fetchGTFSFile(folder, 'shapes.txt');
    const folderAgency = await fetchGTFSFile(folder, 'agency.txt');

    stops = stops.concat(folderStops);
    trips = trips.concat(folderTrips);
    stopTimes = stopTimes.concat(folderStopTimes);
    routes = routes.concat(folderRoutes);
    shapes = shapes.concat(folderShapes);
    agency = agency.concat(folderAgency);
  }

  return { stops, trips, stopTimes, routes, shapes, agency };
}

// Ajouter les routes sous forme de cases à cocher
function addRoutesToMenu(routes) {
  const checkboxContainer = document.getElementById('checkbox-container');
  routes.forEach(route => {
    if (route.route_short_name && route.route_long_name) {
      const checkboxItem = document.createElement('div');
      checkboxItem.className = 'checkbox-item';

      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.value = route.route_id;
      checkbox.style.accentColor = route.route_color ? `#${route.route_color}` : '#000000';

      const label = document.createElement('label');
      label.innerHTML = `${route.route_short_name} - ${route.route_long_name}`;
      label.style.color = route.route_color ? `#${route.route_color}` : '#000000';

      checkboxItem.appendChild(checkbox);
      checkboxItem.appendChild(label);
      checkboxContainer.appendChild(checkboxItem);

      // Ajouter un gestionnaire d'événement pour chaque case à cocher
      checkbox.addEventListener('change', function () {
        if (this.checked) {
          afficherTracéEtArrêts(route.route_id);
        } else {
          retirerTracé(route.route_id); // Retirer le tracé si décoché
        }
      });
    }
  });
}

// Afficher le tracé et les arrêts d'une ligne sélectionnée
async function afficherTracéEtArrêts(routeId) {
  const { stops, trips, stopTimes, shapes, routes } = await loadGTFSData();

  // Filtrer les trips associés à la route sélectionnée
  const routeTrips = trips.filter(trip => trip.route_id === routeId);
  const selectedRoute = routes.find(route => route.route_id === routeId);
  const lineColor = selectedRoute.route_color ? `#${selectedRoute.route_color}` : '#000000';

  if (routeTrips.length > 0) {
    const tripId = routeTrips[0].trip_id; // Choisir un trip associé à la route

    // Récupérer les arrêts associés à ce trip
    const tripStopTimes = stopTimes.filter(st => st.trip_id === tripId);
    const tripStopIds = tripStopTimes.map(st => st.stop_id);
    const tripStops = stops.filter(stop => tripStopIds.includes(stop.stop_id));

    // Ajouter les arrêts sous forme de cercles pleins sur la carte
    tripStops.forEach(stop => {
      const lat = parseFloat(stop.stop_lat);
      const lon = parseFloat(stop.stop_lon);

      // Ajouter un cercle plein de la couleur du tracé pour chaque arrêt
      const marker = L.circleMarker([lat, lon], {
        color: lineColor,   // Couleur du bord
        fillColor: lineColor, // Couleur de remplissage
        fillOpacity: 1, // Opacité de remplissage
        radius: 6 // Taille du cercle (ajuster selon vos préférences)
      });
      markersLayer.addLayer(marker);
    });

    // Récupérer le tracé associé au trip
    const shapeId = routeTrips[0].shape_id;
    const tripShapes = shapes.filter(shape => shape.shape_id === shapeId);
    const shapeCoordinates = tripShapes
      .sort((a, b) => parseInt(a.shape_pt_sequence) - parseInt(b.shape_pt_sequence))
      .map(shape => [parseFloat(shape.shape_pt_lat), parseFloat(shape.shape_pt_lon)]);

    // Tracer la ligne avec la couleur spécifique et stocker sa référence
    const lineLayer = L.polyline(shapeCoordinates, { color: lineColor, weight: 4 }).addTo(map);
    
    // Stocker le tracé dans l'objet linesLayers
    linesLayers[routeId] = lineLayer;
  } else {
    alert("Pas de trajet trouvé pour cette ligne.");
  }
}

// Retirer un tracé de la carte
function retirerTracé(routeId) {
  if (linesLayers[routeId]) {
    map.removeLayer(linesLayers[routeId]); // Supprimer le tracé de la carte
    delete linesLayers[routeId]; // Retirer du stockage des tracés
  }
}

// Charger et afficher les routes dans le menu sous forme de cases à cocher
loadGTFSData().then(data => {
  addRoutesToMenu(data.routes);
});
</script>

<!-- Charger la librairie PapaParse pour parser les fichiers CSV -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>

</body>
</html>
4
